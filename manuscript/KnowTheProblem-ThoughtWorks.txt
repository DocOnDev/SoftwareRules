Around 2009, I was working for ThoughtWorks and helping to lead a large re-write for a leader in the airline industry. The airline had their own in-house development staff complete with architects, designers, project managers, and software developers. While they'd contracted to us for this significant effort, they kept their teams very active in the process - something we welcomed from our clients.

Their commerce website was key to their business strategy. They weren't going to let this project fail. Prior to engaging us, their team had done a great deal of discovery and design. They had a comprehensive architecture design and a backlog of prioritized stories detailed with functional specifications and high-fidelity screen prototypes. The re-write was to take two years to complete and would then replace the old system all at once.

As you might imagine, this wasn't the way ThoughtWorks operated. We convinced them to do the job iteratively and incrementally. We'd tease out and replace aspects of the software while leaving the rest of it in place. No grand ta-da after a multi-year effort. We'd start delivering working software and real value in the first couple of months and every week, if not multiple times per week, thereafter.

We decided to start with the booking flow as this was not only where the majority of customer complaints came from, but it had a direct impact on revenue. Over the past year, abandonment rates were increasing on the site and calls to central booking were increasing. Quite simply - customers booking flights through a central booking agent was more expensive to the company than customers booking flights online.

The primary issue with the booking flow was response times. The site often took over a minute to display a listing of flight options. The listing showed departure and arrival times, flight duration, and tickets available. If you wanted to see details such as the location and length of a layover, you had to click on the flight and wait for another screen to load. If you didn't like the layover, you had to return to the search, which would take another minute or more to display. Booking flights often took thirty minutes or more for a basic round-trip fare. It took less than 10 minutes to book the same flight through an agent. Quite simply - booking flights through a central booking agent was faster and easier than booking flights online.

As this was a critical piece of the solution, the client's designs were quite detailed.

We were presented with a set of pixel-perfect screen flows showing every conceivable interaction on the screen, including failure cases and messages. In some cases, informational messages caused the entire screen to shift up or down by a couple of pixels. Some error messages caused the screen to shift by several lines of text. The flight listings themselves were identical to the existing design, except now when you clicked on a flight, you got an accordion effect that opened up and showed some additional details like the layover city and duration. Flights that didn't have a layover didn't have the accordion details. This seemed like a potentially frustrating user interface where the screen would randomly shift around and some but not all listings had an accordion.

There were specifications for how messages were to be constructed, including how the template messages were to be stored. For example, we could take the template string "Welcome Back \{NAME\}!" and inject the customer name in the designated spot to get "Welcome Back John Smith!". Their model, however, didn't use "\{NAME\}", it used "\{Table.Field\}" where Table indicated the name of the database table and Field indicated the name of the field in that table. For example, "Welcome Back \{Customers.givenmame\} \{Customers.familyname\}!" This seemed like a particularly brittle design. It meant that all database schema changes had the potential to break the system in strange and potentially un-testable ways. It also meant that formatting decisions based on region, such as whether or not given name was displayed first or last were going to be much more difficult to implement and maintain. Finally, it meant that whomever was word-smithing the messages had to also be familiar with the layout of the databases.

Speaking of database schema changes breaking the system - they had a way of mitigating that risk. They presented us with a complete database schema - every table, every field, every relationship, and every view was detailed along with the recommended code for several stored procedures. Their data team was at the ready to go over the details with us. If we had any reasonable suggestions for change, they'd review them and get back to us within three weeks with any approved updates. We were to review the change procedures and controls and sign off that we understood that once development began, schema changes would not be allowed except for under special circumstances. Pre-designing the database and blocking all future changes was one way to ensure the schema didn't break things. But it also meant that we couldn't very well respond to change. Any new functionality requests that required a change to a database would take weeks to get approved. Most likely, there would be a compromise and rather than updating the databases in an optimal way, hacks would be used to get the job done with minimal disruption. This would likely result, over time, in a Frankenstein schema that would then cascade its oddities into the code itself.

Finally, was their object model. This too was quite detailed. They'd pre-designed the objects and documented them all via UML (Unified Modeling Language). The fields, methods, inheritance, and interfaces were all laid out for us to implement. For the most part, the object model looked a great deal like the database schema.

A> Classes are templates that define properties and behavior. Objects are instances of classes that have state and can be manipulated. For simplicity, I am referring to both as objects.

It's common for teams to design their object model to reflect the database schema. On the surface, this makes sense. Data comes from the database, gets manipulated, and gets written back to the database. If the database has a phone number field, the object should also have a phone number field. Get data from the database and put it in an object, update the data in the object, write the object data back to the database - simple. This is such a common practice, that there are tools and libraries that developers can use which automate the process of mapping database fields to object fields.

"If it both makes sense and is very common, what is the problem?"", You might ask.

Good question.

The problem is that a database is for storing data and an object is for acting on that data. A database, no matter how robust, has a limited means of representing data. There are ways of storing numbers that account for the size of the number, the signature (plus or minus), and whether or not it has decimals. There are ways of storing text that account for the length and whether or not it needs to allow for extended characters such as emojis. There are ways of storing dates and times that take timezones into consideration. And there are ways of storing large binary documents - like photos and PDF files. That's about it. If we map the database too tightly to the object model, we are bound by the limits of the database.

To make this more clear - let's focus on phone numbers for a moment.

In this case, the design indicated we were to store a phone number as a number, specifically as an integer. Integers are whole numbers - there is no fractional element; no decimal. This seemed logical enough. For every Customer record in the database, there was a single integer PhoneNumber which represented the primary contact number for that customer. As we might expect, the object model looked quite similar. There was a Customer object which had an integer phoneNumber field.

A> Integers in both an Oracle database and the Java language have a maximum value of 2,147,483,647. While that is ten digits long, it won't hold most phone numbers. For the database, we used LONGINTEGER and for the object, we used BigInteger. For simplicity, we are referring to them as integers.

With the integer PhoneNumber database field mapped directly to the integer phoneNumber object field, we could use objects to read and write data from the database with no problem.

Easy enough. Good to go, right?

Maybe.

Reading and writing a phone number to the database is only one of the things we'd want to do with a phone number. We'd also want to display the phone number, edit the phone number, and maybe verify the phone number.

Let's start simple - let's display the phone number. It's an integer, so if we display it as is, we'll get something like xxxxxxxxxx. That's accurate, but not great. Instead, we probably want to show it using a more common format for a phone number. Say xxx-xxx-xxxx or (xxx) xxx-xxxx. But how?

We might choose to chunk the phone number into three pieces - the first three digits as the area code, the next three digits as the prefix, and the last four digits as the line number.

Since the phone number is technically an integer, we could do this by dividing the phone number by 10,000,000. We'd store the result as the area code and the remainder as the local phone number. We could then take the local phone number (still an integer) and divide it by 10,000. This time the result becomes our prefix and the remainder becomes the line number.

We could also covert the integer to a string of text and then parse out the chunks of text into the area code, prefix, and line number. To do this, we could chunk the text using a substring function to pull out each part, one at a time. We could also use regular expressions to pull out each part, one at a time. There's also the option of using a more sophisticated regular expression to pull out all the parts in one statement.

Alternatively, we could use some formatting library that does the conversions and parsing for us.

So many choices. That's five different ways to accomplish the task - and that is by no means a comprehensive list of our options. If I asked 1000 developers to do this very simple task of displaying an integer phone number formatted as "(xxx) xxx-xxxx", I could very easily get hundreds of different answers. From what general approach they used, to the libraries they used, to the objectes they used, to the methods they used, to the logical structure of the code, to specific syntactical choices, there are literally thousands of possible ways to accomplish this seemingly basic task.

But I digress a bit. The myriad of choices is a challenge, but that's not precisely what I'm driving at here. Just know that when it comes to writing software, there are thousands of ways to accomplish even the most basic of tasks.

Coupling objects to the database is what we're driving at here. So let's get back to it.

Recall that in the object model and in the database, the phone number belongs to the customer and is an integer.

Since the the customer owns the phone number and objects generally act on their own data, then logically the customer object formats their own phone number. That means that there is some method in the customer object that manipulates the integer phone number into a formatted string. Following this basic logic, the code for validating that the phone number has ten digits, that the area code is valid, that the prefix and area code are valid matches, and other such rules is also going to be in the customer object as well.

Seems a tad messy. Why does a customer have to know so much about how phone numbers are formatted?



What is a phone number? We call it a number and it is made up of numerals. So it must be a number - but what kind of number? It does not make sense to do math on a phone number, so it isn't a cardinal number. It doesn't represent a place in a sequence such as first or second, so it isn't an ordinal number. If it is neither cardinal nor ordinal, then it is nominal meaning it is a name or label to identify something. A phone number is a name to uniquely identify a means of contacting someone.

Is a phone number one name or a series of names? Well, a phone number is composed of a country code, an area code, a prefix, and a line number. So technically, a phone number is a composition of names. This is similar to how your full name is composed of elements like your given name, middle name, and surname.

And then there is the question of presentation. Are there parenthesis? Do we hyphenate anything? Do we use any other punctuation? Are spaces significant? The following are proper domestic phone number formats for different countries:

United States: (xxx) xxx-xxxx
United Kingdom: (01xx xx) xx xxx
Canada: xxx/xxx-xxxx
China: (0xxx) xxxx xxxx
Morocco: 07 xx xx xx xx
Australia: (xx) xxxx xxxx
Belgium: 04xx xx xx xx
Poland: xxx-xxx-xxx

You may have noticed that not all of these phone numbers have 10 digits. Some have as few as 8 and some have as many as 11. This is not a comprehensive list. In different regions around the world, local dialing numbers can range from 4 to 13 digits with seemingly infinite possibilities for formatting. Even mobile numbers, which were originally all 10 digits, now range from 10 to 13 digits.

One additional factor to consider is that while an area code once represented a location, such as 216 for Cleveland Ohio, this is no longer reliable. Phone numbers are now portable. People who reside in Cleveland Ohio can have cell phone numbers with a Cleveland Mississippi area code.







√ Customer provided detailed designs of screens, architecture, database schemas, and the object model.
* Design accounted for one way, round trip, multi-stop, open-ended, children, pets, and other special circumstances
* Decided to start simple and build as we needed with the detailed design as a guide, but not a requirement
* In September 2009 - learned new security measures were being put into place by the TSA, effective January 2010 [^TSARegs].
* Were able to get new passenger identification requirements in place


[^TSARegs]: “Air Travel Rules FAQ.” Findlaw, June 21, 2016. https://www.findlaw.com/consumer/travel-rules-and-rights/air-travel-rules-faq.html.
