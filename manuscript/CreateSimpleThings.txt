{#create_simple_things}
# Create simple things in small steps.

{blurb, icon: quote-left}
The most fundamental problem in software development is complexity. There is only one basic way of dealing with complexity: divide and conquer.

C> -- Bjarne Stroustrup
{/blurb}

## Create Simple Things

This sounds easy enough. Create simple things. But, what is a simple thing?

Simple might indicate something that is easy to understand or something that has few components. Simple might also indicate something that is lacking intellect or something that is gullible. As we are talking about code, which is non-sentient, the former makes more sense.

Given this, we might say that simple code is easy to understand and has few components. But I think this definition lacks something. I could have code that is easy to understand and has few components but fails to reliably accomplish the desired outcome. It seems very important that the code accomplishes the desired outcomes. This is perhaps the most important thing.

So maybe our rules for simplicity are:
1. Accomplishes the desired outcomes
1. Is easy to understand
1. Has few components

That's not bad. I could live with it.

As it turns out, the industry has a definition of simplicity that is similar to ours. Kent Beck[^KentBeck], creator of jUnit[^jUnit] and a member of the team that created Extreme Programming (XP)[^XP], describes Simple Design using 4 rules[^SimplicityRules]:

1. Passes all the tests.
1. Express every idea we need to express.
1. Duplicates no behavior.
1. Has no superfluous parts.

[^KentBeck]: Kent Beck is the creator of extreme programming. Beck was one of the original signatories of the Agile Manifesto. Kent is also known for his work as a proponent of TDD. “Kent Beck.” Wikipedia. Wikimedia Foundation, February 7, 2020. https://en.wikipedia.org/wiki/Kent_Beck.

[^jUnit]: jUnit is a unit testing framework for Java, originally written by Kent Beck, Erich Gamma, et. al. jUnit was instrumental in fostering the adoption of TDD. “The New Major Version of the Programmer-Friendly Testing Framework for Java.” JUnit 5. Accessed November 3, 2020. https://junit.org/. 

[^XP]: You know, like XP // TODO: Reference for Extreme Programming & Blurb for Extreme Programming

[^SimplicityRules]: The simplicity rules, which are a part of XP, are a set of criteria for determining if code is "simple enough." Cunningham, Ward, Kent Beck, and Ron Jeffries. “XP Simplicity Rules.” wiki.c2.com, November 12, 2014. https://wiki.c2.com/?XpSimplicityRules.

There are numerous variations of the 4 rules. The order has been changed slightly over the years and different folks, including Kent, have articulated the rules in various ways. But the essence of the rules has not changed. Whether we say "Duplicates no behavior", "Duplicates no logic", or "Contains no duplication" is primarily a matter of preference.

### Passes all the tests.

What types of tests? - unit tests? What does that mean?
What about acceptance and regression?
Do all tests need to pass all the time?
The assurance you get from passing tests.
The cognitive/chemical jolt you get from tests passing.
The safety net you get from a set of tests.



First and foremost, Kent's idea of simple includes tests. Now, he doesn't specify automated tests, much less unit tests or Test-Driven Development (TDD)[^TDD] in his definition.

[^TDD]: Test-driven development is a style of programming that involves a cycle of three activities executed in short cycles: Test, Code, Refactor. “Test-Driven Development.” wiki.c2.com, November 5, 2014. http://wiki.c2.com/?TestDrivenDevelopment. 

{aside}
#### Test-Driven Development (TDD)

Test-driven development is a style of programming that involves a cycle of three activities executed in short cycles: Test, Code, Refactor. The steps can be described as follows:

- Test
  - write a unit test specifying a specific behavior
  - run the test
    - confirm it fails because the program lacks that behavior
- Code
  - write rudimentary code in order to make the test pass
    - might involve duplication, non-expressive names, etc.
  - confirm the new test passes
  - confirm all tests pass
- Refactor
  - eliminate duplication
  - clearly express intent
  - remove superfluous parts
  - confirm all tests pass
{/aside}

I think TDD is a fair inference considering these are Kent's rules. But that's not the point at the moment. The point, dear reader, is that Kent's rules for simple design include that the code passes all the tests.

All the tests. Not some of the tests. All of them.

All of what tests?
All of the tests we have?
All of the tests we decided to write?

All of the tests necessary to verify the software works as desired. The point of "passes all the tests" is that the code reliably accomplishes the desired outcome.

What I like about Kent's articulation is that it not only states that the code should reliably accomplish the desired outcome, but that we have a means of proving to ourselves that it does so and assuring ourselves that it will continue to do so.

Kent's rules are in order of importance. While rule 2 and 3 have sometimes swapped places over the years due to changes in industry trends, rule number one has always been rule number one. Make sure the software does what it is supposed to do.

### Expresses every idea we need to express


### Duplicates no behavior

We hear a lot about duplicate code in the industry. There are automated code checkers called linters that look for code duplication and metrics dashboards that tell you how much of it you have. These tools look for patterns in the structure of the code. At a minimum, they look for code that is character for character identical.

But Kent is specific with his words. He doesn't say "Duplicates no code", he says, "Duplicates no behavior". Kent is not just talking about duplicate code, he's talking about duplicate behavior. And this is an important distinction.

As it turns out, when you have code that is duplicate in structure and content, you very likely have duplicate behavior. This is what makes code linters helpful. They are able to find places where someone copied code from one area of the source code and pasted it into another. But linters are not good at identifying duplicate behavior.

Let's say we have a screen that shows the average bowling score for a player during a tournament.

{format: Java, caption: Average Tournament Score}
~~~
  // Get tournament scores
  List<Integer> scores = getTournamentScores();

  // Calculate Average Score
  Integer total = 0;
  for ( Integer score : scores ) {
      total += score;
  }
  Double average = Double.valueOf(total/scores.size());
  String displayAverage = average.toString();

  // Display the average
  Text averageText = new Text(displayAverage);

  Group root = new Group(text);   
  Scene scene = new Scene(root, 600, 300);  

  stage.setTitle("Tournament Stats"); 
  stage.setScene(scene); 
     
  stage.show(); 
~~~

A few months later, we need a PDF report that includes the average bowling score for a player for the current year. So we grab the code for calculating the average from the screen and we drop it in. It works.

{format: Java, caption: Average Annual Score}
~~~
  // Get annual scores
  List<Integer> scores = getAnnualScores();

  // Calculate Average Score
  Integer total = 0;
  for ( Integer score : scores ) {
      total += score;
  }
  Double average = Double.valueOf(total/scores.size());
  String displayAverage = average.toString();

  // Display the average
  Font font = FontFactory.getFont(COURIER, 16, BLACK);
  Chunk averageChunk = new Chunk(displayAverage, font);

  Document document = new Document();
  FileOutputStream pdf = new FileOutputStream("AnnualStats.pdf");
  PdfWriter.getInstance(document, pdf);
   
  document.open();

  document.add(averageChunk);
~~~

Let's say we end up doing this a few times. There are different screens and different reports, all of which show average scores based on different criteria such as player age, gender, or region.

Our linter will catch these because they are all literally identical in the way they calculate the average. Every single one of them has this exact same code.

{format: Java, caption: Our Duplicated Code}
~~~
  // Calculate Average Score
  Integer total = 0;
  for ( Integer score : scores ) {
      total += score;
  }
  Double average = Double.valueOf(total/scores.size());
  String displayAverage = average.toString();
~~~

Now, how likely do you think that is? That we've duplicated the same code a dozen times and nobody made a single change to it?

Yeah. Not likely.

It is far more likely that in the dozen instances of average calculation, we have minor differences. There are probably three or four different variants of the same code. We'll have different variable names because total isn't descriptive enough, whereas annualTotal or tournamentTotal is more descriptive. And we'll have different formatting because some of us think that the for loop is concise enough to fit onto one line and some of us think that for loops should never be on a single line.

{format: Java, caption: Annual Score with new variables}
~~~
  // Calculate Average Annual Score
  Integer annualTotal = 0;
  for ( Integer score : scores ) {
      annualTotal += score;
  }
  Double average = Double.valueOf(annualTotal/scores.size());
  String displayAverage = average.toString();
~~~

{format: Java, caption: Tournament Score with new variables and formatting}
~~~
  // Calculate Tournament Average
  Integer tournamentTotal = 0;
  Double tournamentAvg = 0;
  Integer scoreCount = scores.size();
  for ( Integer score : scores ) { tournamentTotal += score; }
  tournamentAvg = Double.valueOf(tournamentTotal/scoreCount);
  String displayAverage = tournamentAvg.toString();
~~~

The more sophisticated linters will still catch this. They ignore insignificant characters such as spaces, tabs and carriage returns. They also ignore comments in the code and can intelligently evaluate variables. These differences will still get caught by any decent linter.

Over time, we make minor modifications to the different areas of the code that calculate averages. Maybe we change where on the screen it is displayed or maybe we want to change the formatting of the display of the average on the screen. Whatever the reasons, the implementation of the various copies of the duplicate code drift over time.

{format: Java, caption: Annual Score with empty check}
~~~
  // Calculate Average Annual Score
  Integer annualTotal = 0;
  Double average = 0.0;

  if (!scores.isEmpty()) {
    for ( Integer score : scores ) {
        annualTotal += score;
    }
    average = Double.valueOf(annualTotal/scores.size());
  }

  String displayAverage = average.toString();
~~~

{format: Java, caption: Tournament score using summary statistics}
~~~
  // Calculate Tournament Average
  IntSummaryStatistics stats = tournamentScores.stream()
    .mapToInt((a) -> a)
    .summaryStatistics();

  String tournamentAverage = stats.getAverage().toString();
~~~

At this point, these two examples are distinctly different in structure, yet they are identical in behavior - they both calculate the average of a set of scores.

As we mentioned earlier, the rule is not "Duplicates no code", but quite deliberately, "Duplicates no behavior."

Duplicate behavior is the actual problem. As we've now seen in our example here, when you have duplicate code - significantly similar in structure and function - you usually have duplicate behavior. But Kent is talking about _any_ duplicate behavior, even those that are structurally different.

Why is that? Why is duplicate behavior an issue?

Let's return to our simple example of calculating an average of bowling scores.

Our handy little application is being used by a number of small leagues and amateur bowlers. Eventually, the United States Bowling Congress (USBC)[^USBC] takes notice and wants to use it, but they need it to support handicaps. This means that the screens and reports that currently show scores and averages will need to show the base values along with the values adjusted for handicap.

[^USBC]: “Home - United States Bowling Congress.” Accessed November 1, 2020. https://bowl.com/. 

To calculate a handicap, you need to take an average of the scores over a minimum of three most recent games, subtract the average from a league basis score to get a delta, and multiply the delta by a league percentage to get the handicap. This is certainly going to make our code more complicated.

But there's more. In league bowling, your handicap changes over time. As you bowl, you are accumulating new scores. Those scores may very well alter your base average, which will alter your delta, which will alter your handicap. So when we want to show the average score for the season along with the average score with handicap for the season, we will have to calculate multiple averages in order to figure out what the handicap adjusted score would have been and then finally calculate the average of all the handicap adjusted scores.

You might be thinking, "No problem. We'll just record the base score and the handicap adjusted score for every game so that we only need to calculate the handicap once." This seems reasonable, except leagues want to run what if scenarios to make sure their basis scores and percentages are fair and it is not unheard of for a league to adjust their handicap basis score or percentage retro-actively in the middle of a season.

Whoah. Didn't see that one coming, did we?

Okay, maybe you did. But my last league bowling experience was 2004 when my then 10 year old son and I joined a father:son league. As far as I know, they didn't use handicaps. This craziness was news to me, my friend.

Given the promise of a lot of new customers, we're happy to add in this new behavior. But how? Where do we begin? Maybe we start with reports and then after we've tested it, we add it into the screens? Maybe we start with the most commonly used aspects of the software?

However we go about this, we're going to need to do a lot of testing. Think about it - the change to annual average is going to be completely different from the change to tournament average. We can't complete the new behavior in one and then copy:paste into the other any more. They're too structurally different for that to work, even though they have the same behavior.

Well, wait a minute... What if we took this opportunity to first get them all back in sync? What if we chose our favorite version of the average calculation - the one that works the fastest or is the easiest to read or maybe is best based on some other set of criteria - and we replaced all of the versions with that one? We could make them all the same again! And that way, we could make the handicap calculation change once and then know it would work for all of them.

That's pretty good. It would prevent us from having to write 12 different versions of the handicap calculation logic. That's handy. (No pun intended) But we still have 12 different copies of the average calculation and we now know that, given time, we'll eventually drift into having 12 different versions of the code floating around. And who knows, what if the USBC does a study and determines that the current handicap calculations need to change in order to be more equitable. Ugh. 12 different changes all over again.

This is the problem with duplicate behavior. Whenever you have duplicate behavior, you have multiple areas of the code that might need to change. Any change, no matter how simple, takes longer for each implementation of the behavior. Not only that - what if you miss one? Or two? Duplicate behavior means more work and more bugs.

What we need to do here is create *one* instance of the average score calculation. It needs to be clean and simple. Calculating an average score needs to be the one job it does; its single responsibility. Anywhere we need an average score calculated, we make a call to this one instance, passing it a list of scores, and it gives us back the average.

{format: Java, caption: Calculate Average Method}
~~~
public class ScoreCalculator {
  public static Double average(List<Integer> scores) {

    IntSummaryStatistics stats = scores.stream()
      .mapToInt((a) -> a)
      .summaryStatistics();
          
    return stats.getAverage();
  }
}
~~~

{format: Java, caption: Average Tournament Score}
~~~
  // Get tournament scores
  List<Integer> scores = getTournamentScores();

  // Calculate Average Score
  String displayAverage = ScoreCalculator.average(scores).toString();

  // Display the average
  Text averageText = new Text(displayAverage);

  Group root = new Group(text);   
  Scene scene = new Scene(root, 600, 300);  

  stage.setTitle("Tournament Stats"); 
  stage.setScene(scene); 
     
  stage.show(); 
~~~

{format: Java, caption: Average Annual Score}
~~~
  // Get annual scores
  List<Integer> scores = getAnnualScores();

  // Calculate Average Score
  String displayAverage = ScoreCalculator.average(scores).toString();

  // Display the average
  Font font = FontFactory.getFont(COURIER, 16, BLACK);
  Chunk averageChunk = new Chunk(displayAverage, font);

  Document document = new Document();
  FileOutputStream pdf = new FileOutputStream("AnnualStats.pdf");
  PdfWriter.getInstance(document, pdf);
   
  document.open();

  document.add(averageChunk);
~~~

Having completed that exercise, we now have one place where score averages are calculated. Any change to how score averages are calculated can be made in one place and will automatically work everywhere in the application.

One commonly accepted principle of software development is The Single Responsibility Principle (SRP)[^SRP]. SRP states that each software module should have one and only one reason to change. While the principle does not state this explicitly, I tend to add, "Each reason to change should be represented in one and only one module." So each module within a solution has a specific and discrete purpose and is the only module within the solution that provides that purpose.

[^SRP]: “Single Responsibility Principle.” wiki.c2.com, March 23, 2010. https://wiki.c2.com/?SingleResponsibilityPrinciple. 

This is what is means to duplicate no behavior. Each module within a solution has a specific, discrete, and unique purpose.

Simple things are not often easy to create. In fact, we often start with a complicated thing and then break it apart into simple pieces.

## In Small Steps
