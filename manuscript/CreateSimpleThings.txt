{#create_simple_things}
# Create simple things in small steps.

{blurb, icon: quote-left}
The most fundamental problem in software development is complexity. There is only one basic way of dealing with complexity: divide and conquer.

C> -- Bjarne Stroustrup
{/blurb}

## Create Simple Things

This sounds easy enough. Create simple things. But, what is a simple thing?

Simple might indicate something that is easy to understand or something that has few components. Simple might also indicate something that is lacking intellect or something that is gullible. As we are talking about code, which is non-sentient, the former makes more sense.

Given this, we might say that simple code is easy to understand and has few components. But I think this definition lacks something. I could have code that is easy to understand and has few components but fails to reliably accomplish the desired outcome. It seems very important that the code accomplishes the desired outcomes. This is perhaps the most important thing.

So maybe our rules for simplicity are:
1. Accomplishes the desired outcomes
1. Is easy to understand
1. Has few components

That's not bad. I could live with it.

As it turns out, the industry has a definition of simplicity that is similar to ours. Kent Beck[^KentBeck], creator of jUnit[^jUnit] and a member of the team that created Extreme Programming (XP)[^XP], describes Simple Design using 4 rules[^SimplicityRules]:

1. Passes all the tests.
1. Clearly expresses what we intend.
1. Duplicates no behavior.
1. Has no superfluous parts.

[^KentBeck]: Kent Beck is the creator of extreme programming. Beck was one of the original signatories of the Agile Manifesto. Kent is also known for his work as a proponent of TDD. “Kent Beck.” Wikipedia. Wikimedia Foundation, February 7, 2020. https://en.wikipedia.org/wiki/Kent_Beck.

[^jUnit]: jUnit is a unit testing framework for Java, originally written by Kent Beck, Erich Gamma, et. al. jUnit was instrumental in fostering the adoption of TDD. “The New Major Version of the Programmer-Friendly Testing Framework for Java.” JUnit 5. Accessed November 3, 2020. https://junit.org/. 

[^XP]: You know, like XP // TODO: Reference for Extreme Programming & Blurb for Extreme Programming

[^SimplicityRules]: The simplicity rules, which are a part of XP, are a set of criteria for determining if code is "simple enough." Cunningham, Ward, Kent Beck, and Ron Jeffries. “XP Simplicity Rules.” wiki.c2.com, November 12, 2014. https://wiki.c2.com/?XpSimplicityRules.

There are numerous variations of the 4 rules. The order has been changed slightly over the years and different folks, including Kent, have articulated the rules in various ways. But the essence of the rules has not changed. Whether we say "Duplicates no behavior", "Duplicates no logic", or "Contains no duplication" is primarily a matter of preference.

### Passes all the tests.

First and foremost, Kent's idea of simple includes tests. Now, he doesn't specify automated tests, much less unit tests or Test-Driven Development (TDD)[^TDD] in his definition.

[^TDD]: Test-driven development is a style of programming that involves a cycle of three activities executed in short cycles: Test, Code, Refactor. “Test-Driven Development.” wiki.c2.com, November 5, 2014. http://wiki.c2.com/?TestDrivenDevelopment. 

I think TDD is a fair inference considering these are Kent's rules. But that's not the point at the moment. The point, dear reader, is that Kent's rules for simple design include that the code passes all the tests.

All the tests. Not some of the tests. All of them.

All of what tests?
All of the tests we have?
All of the tests we decided to write?

All of the tests necessary to verify the software works as desired. The point of "passes all the tests" is that the code reliably accomplishes the desired outcome, that we have a means of proving to ourselves that it does so, and we have a means of assuring ourselves that it will continue to do so.

{aside}
For more on testing, take a look at the section entitled, ["Validate before, during, and after"](#validate_always)
{/aside}

Kent's rules are in order of importance. While rule 2 and 3 have sometimes swapped places over the years due to changes in industry trends, rule number one has always been rule number one. Make sure the software does what it is supposed to do.

### Clearly expresses what we intend

Source code is an interesting thing. One might think that source code is designed to provide instructions to a machine. And they wouldn't be entirely wrong. Except that most source code these days is several layers away from being able to be truly understood by a computer whereas it is immediately understood by humans (or should be).

Languages like Java or C# are designed for humans to read and write. If we want machines to actually perform the task described by the code, then the source is run through a compiler which translates the source to another language. That language is often also not runnable by a machine, but is an intermediate language that is more easily transformed into machine code. This intermediate language code is then compiled to machine code. The compilation to machine code is often done in real time.

Let's take the Java language as an example. A developer writes some software that does something spiffy, like calculates a bowling score average. When the developer builds the software, the compiler converts the Java code to something called bytecode. This is an intermediate step. Bytecode cannot be run by a computer directly. Instead, when a java application is started, the bytecode is loaded into a Java Virtual Machine (JVM) which is specific to the hardware it is running upon. That JVM then converts the bytecode to machine code in real-time as needed.

Okay. That's enough of that.

I tell you this because I want you to understand that modern languages are as much, if not more, about human to human communication than they are about human to machine communication. If we wanted to talk to the machine directly, we would write in machine code. While higher-level languages make it easier for us humans to reason about a problem and think less about how to express that problem in 0s and 1s, they have the additional advantage of being linguistically expressive. We can genuinely convey ideas in code, much like we can in prose.

When we say that the code clearly expresses what we intend, we are talking about how those intentions are expressed to other humans. How clearly have we expressed the intent to the future version of ourselves? How clearly have we expressed the intent to a complete stranger who inherits our project?

{blurb, icon:quote-left}
 *'Any fool can write code that a computer can understand. Good programmers write code that humans can understand.'*
 C> -- Martin Fowler
 {/blurb}

Our goal here is that when we look at a piece of code, it immediately tells us what it does. Classes, methods, and variables all have names that reveal their purpose. Concepts are expressed independent of one another in concise and unambiguous ways. Good code adheres to the principle of least astonishment[^LeastAstonishment] - it doesn't surprise us in any way.

[^LeastAstonishment]: “Principle of Least Astonishment.” wiki.c2.com, November 26, 2014. https://wiki.c2.com/?PrincipleOfLeastAstonishment.

Let's explore the concepts of clear expression and the principle of least surprise by looking at an excerpt from a story. First we'll read the excerpt and then I'll ask you a few questions about how clearly the details were expressed.

{blurb, icon:book, caption: The Incident}
Chris was growing impatient while waiting for the police to arrive. Despite anxiously awaiting the knock at the door, Chris still paused to peer through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer in a crisp white shirt, blue work pants and heavy black boots, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small table and four chairs.

They sat, he facing the hall and she facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said the officer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and I saw them, tall and heavy set, in the apartment with a telescope. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

Based on what you read, how would you answer the following questions?
* What was Chris anxious about?
* What was Chris wearing during the discussion?
* What room were they seated in?
* What was the officer facing when seated?
* Where was the telescope during the incident?
* How many people did Chris see in the apartment?

Let's see if we can adjust the story a bit to make the answers to these questions more clear. Our intent is to maintain the integrity of the story; to make it more clear what has transpired without altering the outcome. Let's make small changes, testing each one to ensure it made the story more clear without altering the essence of the story itself.

{blurb, icon:book, caption: The Incident - What was Chris anxious about?}
Anxious about being late for work, Chris was waiting for the police to arrive. Chris heard a knock on the door and peered through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer in a crisp white shirt, blue work pants and heavy black boots, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small table and four chairs.

They sat, he facing the hall and she facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said the officer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and I saw them, tall and heavy set, in the apartment with a telescope. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

We now have additional detail about Chris. Chris is anxious about being late for work. We also removed some redundancy. There was no need to use impatient and anxious to describe Chris. Anxious is sufficient and there is now one place to update if we decide that nervous or excited are better ways of articulating the mood.

We have additional clarity, we've reduced redundancy, and we've not altered the essence of the story. This was a good first change. Let's make another one.

{blurb, icon:book, caption: The Incident - What was Chris wearing?}
Anxious about being late for work, Chris was waiting for the police to arrive. While waiting, Chris got dressed for work in a crisp white shirt, blue work pants, and heavy black boots. Finally, Chris heard a knock on the door and peered through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small table and four chairs.

They sat, he facing the hall and she facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said the officer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and I saw them, tall and heavy set, in the apartment with a telescope. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

We've confirmed that Chris was wearing a crisp white shirt, blue work pants, and heavy black boots during the discussion. Did that surprise any of you? The original text was unclear. It would have been easy to assume the officer's attire was being described. The original text mixed different ideas into a single sentence; the greeting and what Chris was wearing. We extracted the attire detail and put it into an independent sentence, making things more clear.

Now that it is independent, we are able to make a judgement about the value of the attire details while maintaining the greeting. Honestly, the attire does not seem relevant to the essence of the story and could be removed entirely. It is a superfluous detail. We'll remove it going forward.

So again, we have additional clarity and we've not altered the essence of the story. Let's keep going and see if we can clarify which room they're in.

{blurb, icon:book, caption: The Incident - What room were they seated in?}
Anxious about being late for work, Chris was waiting for the police to arrive. Finally, Chris heard a knock on the door and peered through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small coffee table and four wing chairs in the living room.

They sat, he facing the hall and she facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said the officer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and I saw them, tall and heavy set, in the apartment with a telescope. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

They were in the living room. Did you think they were at a dining table of some sort? Did you guess they were in a dining room or kitchen? I did. I wasn't expecting them to be in the living room. Providing just a little more detail about the table and chairs completely changed my perspective.

So far, so good. We're a lot more clear on the details and we've eliminated concepts that didn't need to be included. And still, we've not altered the essence of the story. What about the question of what each of them was facing?

{blurb, icon:book, caption: The Incident - What was the officer facing?}
Anxious about being late for work, Chris was waiting for the police to arrive. Finally, Chris heard a knock on the door and peered through the peephole. Seeing a female officer, Chris opened the door.

"Hello.", said Chris, greeting the officer, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small coffee table and four wing chairs in the living room.

They sat, he facing the hall and she facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said the officer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and I saw them, tall and heavy set, in the apartment with a telescope. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

The officer was facing a large photo of flowers in a vase. If you're like me, this caused some tension for you. The text didn't indicate anything conclusive about either individual's gender identity. I personally found the references to "he" and "she" to be jarring. I suddenly had to decide how our characters identified. Chris is a gender neutral name and I didn't know anything about the officer other than a last name. I felt tension and then decided that Chris must be female because most police officers are male. That didn't feel great, but it made the most sense to me at the time. I needed to do something to relieve the tension in order to move on.

Now, we've cleared some of the tension by introducing a gender identity for the officer. But if we think about it, gender doesn't seem to be material to the story. Let's eliminate the tension altogether by referring to the specific characters instead of using pronouns and let's get rid of the "female officer" text.

{blurb, icon:book, caption: The Incident - Eliminate the tension}
Anxious about being late for work, Chris was waiting for the police to arrive. Finally, Chris heard a knock on the door and peered through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small coffee table and four wing chairs in the living room.

They sat, Chris facing the hall and Officer Mercer facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said Mercer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and I saw them, tall and heavy set, in the apartment with a telescope. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

That works. You can assume whatever you want about the gender identities of our characters. At this moment, they are not material to the essence of the story. And now, we don't need to infer who is facing where.

What about that telescope? Where was it?

{blurb, icon:book, caption: The Incident - Where was the telescope?}
Anxious about being late for work, Chris was waiting for the police to arrive. Finally, Chris heard a knock on the door and peered through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small coffee table and four wing chairs in the living room.

They sat, Chris facing the hall and Officer Mercer facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said Mercer, "Provide as much detail as you can."

"Yes. of course. Well, I just got home from the gym, and noticed something odd in the apartment across the way. So I got out my telescope to take a closer look and I saw them, tall and heavy set, in the apartment. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

The telescope belongs to Chris and was in his apartment. He did not see them holding a telescope. He used his telescope to see them. In the original story, either could have been the case.

The story keeps getting more clear and more focused. We've simultaneously maintained the essence. On to our last question - How many people did Chris see in the apartment?

{blurb, icon:book, caption: The Incident - How many people did Chris see in the apartment?}
Anxious about being late for work, Chris was waiting for the police to arrive. Finally, Chris heard a knock on the door and peered through the peephole. Seeing an officer, Chris opened the door.

"Hello.", said Chris, greeting the officer, "Am I glad to see you."

"You are Chris Estes?", asked the officer.

"I am.", said Chris.

"Officer Mercer. You reported witnessing a crime?"

"I did. Come in. Sit down.", said Chris, gesturing to a small coffee table and four wing chairs in the living room.

They sat, Chris facing the hall and Officer Mercer facing a large photo of flowers in a vase. "Okay. So tell me what you saw.", said Mercer, "Provide as much detail as you can."

"Yes. of course. Well, I noticed something odd in the apartment across the way. So I got out my telescope to take a closer look and I saw two men, one tall and one heavy set, in the apartment. They were taking her stuff, putting it in boxes, and carrying it out the door to a white truck in the street."
{/blurb}

Chris saw two men. In the original telling, we may have assumed he saw one person who was tall and heavy set. By adding a little more clarity, we now know that there were two men in the apartment, one of whom was tall and the other was heavy set.

This still isn't a fantastic story, but it is much better. We've reduced ambiguity, eliminated some superfluous parts, and lowered friction. This version of the story is far easier to read and we've maintained the essence. The story now more clearly expresses what we intend.

What we've been doing is a practice developers refer to as refactoring[^Refactoring]. Refactoring is when developers change the structure of code without changing its behavior. In our exercise, we were changing the structure of the excerpt without altering the essence of the story. Just as a developer would do when refactoring, we didn't try to rewrite the story all at once, nor did we try to tell a different story. We had a meaning that we wanted to convey, information that we wanted to impart. We made small changes and tested each one against our desired outcomes. Were we true to the essence of the story? Did we eliminate unnecessary details? Did we make it more clear? Did we isolate ideas that didn't necessarily need to be expressed together? Did we make the story easier to edit in the future?

[^Refactoring]: Fowler, Martin. “Refactoring Home Page.” Refactoring. Accessed November 8, 2020. https://refactoring.com/. 

Now that we're conceptually familiar with refactoring and we've seen the notion applied to prose, let's take a look at some code. Take a look at this code. What do you suppose it is intended to do? Does it work as intended? Can you primarily read it or do you need to primarily interpret it?

{format: Java, caption: Example Code - Original}
~~~

public class Game
{
    public int P1point = 0;
    public int P2point = 0;
    
    public String P1res = "";
    public String P2res = "";
    private String player1Name;
    private String player2Name;

    public Game(String player1Name, String player2Name) {
        this.player1Name = player1Name;
        this.player2Name = player2Name;
    }

    public String getScore(){
        String score = "";
        if (P1point == P2point && P1point < 4)
        {
            if (P1point==0)
                score = "Love";
            if (P1point==1)
                score = "Fifteen";
            if (P1point==2)
                score = "Thirty";
            score += "-All";
        }
        if (P1point==P2point && P1point>=3)
            score = "Deuce";
        
        if (P1point > 0 && P2point==0)
        {
            if (P1point==1)
                P1res = "Fifteen";
            if (P1point==2)
                P1res = "Thirty";
            if (P1point==3)
                P1res = "Forty";
            
            P2res = "Love";
            score = P1res + "-" + P2res;
        }
        if (P2point > 0 && P1point==0)
        {
            if (P2point==1)
                P2res = "Fifteen";
            if (P2point==2)
                P2res = "Thirty";
            if (P2point==3)
                P2res = "Forty";
            
            P1res = "Love";
            score = P1res + "-" + P2res;
        }
        
        if (P1point>P2point && P1point < 4)
        {
            if (P1point==2)
                P1res="Thirty";
            if (P1point==3)
                P1res="Forty";
            if (P2point==1)
                P2res="Fifteen";
            if (P2point==2)
                P2res="Thirty";
            score = P1res + "-" + P2res;
        }
        if (P2point>P1point && P2point < 4)
        {
            if (P2point==2)
                P2res="Thirty";
            if (P2point==3)
                P2res="Forty";
            if (P1point==1)
                P1res="Fifteen";
            if (P1point==2)
                P1res="Thirty";
            score = P1res + "-" + P2res;
        }
        
        if (P1point > P2point && P2point >= 3)
        {
            score = "Advantage player1";
        }
        
        if (P2point > P1point && P1point >= 3)
        {
            score = "Advantage player2";
        }
        
        if (P1point>=4 && P2point>=0 && (P1point-P2point)>=2)
        {
            score = "Win for player1";
        }
        if (P2point>=4 && P1point>=0 && (P2point-P1point)>=2)
        {
            score = "Win for player2";
        }
        return score;
    }
    
    public void SetP1Score(int number){
        
        for (int i = 0; i < number; i++)
        {
            P1Score();
        }
            
    }
    
    public void SetP2Score(int number){
        
        for (int i = 0; i < number; i++)
        {
            P2Score();
        }
            
    }
    
    public void P1Score(){
        P1point++;
    }
    
    public void P2Score(){
        P2point++;
    }

    public void wonPoint(String player) {
        if (player == "player1")
            P1Score();
        else
            P2Score();
    }
}
~~~

I can see that this is related to tennis. I can infer tennis from the words "Love", "Fifteen", "Thirty", "Forty", "Deuce", and "Advantage". And I can see that there is some notion of winning a point and some notion of score. I can see that there are two players involved. But it is hard to figure out if the scoring works as it should.

Fortunately for us, we have a satisfactory set of automated tests that verify a wide range of possible game scenarios. According to these tests, the code does score games properly. Those tests allow us to make changes to the code and verify that the behavior (the essence) of the code has been maintained. Let's see if we can make this code more readable by refactoring it, much like we did the prose. We are going to concentrate on the getScore() method. I'll show you all the code as we go along, but if you'd prefer not to read all of it, then just take notice of the changes to getScore().

Normally, refactoring involves tiny steps. We want to make a small, safe change and verify that everything is still working. We do this over and over again as we improve the code. Small changes are easy to undo should we break something. Small changes mean we spend very little refactoring time in a broken state. When I say very little time, I mean seconds or possibly minutes, but never hours. As a result, we can safely stop refactoring at any time, quickly get to a working state, and check in the code.

This code is in pretty bad shape. And while I actually did the refactoring in tiny steps, I don't want to drag you through it all. So I am going to show the refactoring in larger steps.

Let's start out our refactoring by giving things more descriptive names.

{format: Java, caption: Tennis Class - Descriptive names}
~~~
public class TennisGame
{
    private String playerOneName;
    public int playerOnePoints = 0;
    public String playerOneScore = "";

    private String playerTwoName;
    public int playerTwoPoints = 0;
    public String playerTwoScore = "";


    public TennisGame(String player1Name, String player2Name) {
        this.playerOneName = player1Name;
        this.playerTwoName = player2Name;
    }

    public String getScore(){
        String score = "";
        if (isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrUnder(playerOnePoints))
        {
            if (playerOnePoints ==0)
                score = "Love";
            if (playerOnePoints ==1)
                score = "Fifteen";
            if (playerOnePoints ==2)
                score = "Thirty";
            score += "-All";
        }
        if (isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrOver(playerOnePoints))
            score = "Deuce";
        
        if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && playerTwoPoints ==0)
        {
            if (playerOnePoints ==1)
                playerOneScore = "Fifteen";
            if (playerOnePoints ==2)
                playerOneScore = "Thirty";
            if (playerOnePoints ==3)
                playerOneScore = "Forty";
            
            playerTwoScore = "Love";
            score = playerOneScore + "-" + playerTwoScore;
        }
        if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && playerOnePoints ==0)
        {
            if (playerTwoPoints ==1)
                playerTwoScore = "Fifteen";
            if (playerTwoPoints ==2)
                playerTwoScore = "Thirty";
            if (playerTwoPoints ==3)
                playerTwoScore = "Forty";
            
            playerOneScore = "Love";
            score = playerOneScore + "-" + playerTwoScore;
        }
        
        if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isFortyOrUnder(playerOnePoints))
        {
            if (playerOnePoints ==2)
                playerOneScore ="Thirty";
            if (playerOnePoints ==3)
                playerOneScore ="Forty";
            if (playerTwoPoints ==1)
                playerTwoScore ="Fifteen";
            if (playerTwoPoints ==2)
                playerTwoScore ="Thirty";
            score = playerOneScore + "-" + playerTwoScore;
        }
        if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isFortyOrUnder(playerTwoPoints))
        {
            if (playerTwoPoints ==2)
                playerTwoScore ="Thirty";
            if (playerTwoPoints ==3)
                playerTwoScore ="Forty";
            if (playerOnePoints ==1)
                playerOneScore ="Fifteen";
            if (playerOnePoints ==2)
                playerOneScore ="Thirty";
            score = playerOneScore + "-" + playerTwoScore;
        }
        
        if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isFortyOrOver(playerTwoPoints))
        {
            score = "Advantage " + playerOneName;
        }
        
        if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isFortyOrOver(playerOnePoints))
        {
            score = "Advantage " + playerTwoName;
        }

        if (isOverForty(playerOnePoints) && isAheadByTwoOrMore(playerOnePoints, playerTwoPoints))
        {
            score = "Win for " + playerOneName;
        }
        if (isOverForty(playerTwoPoints) && isAheadByTwoOrMore(playerTwoPoints, playerOnePoints))
        {
            score = "Win for " + playerTwoName;
        }
        return score;
    }

    private boolean isAheadByTwoOrMore(int firstPlayerPoints, int secondPlayerPoints) {
        return (firstPlayerPoints - secondPlayerPoints)>=2;
    }

    private boolean isOverForty(int playerPoints) {
        return playerPoints >=4;
    }

    private boolean isFirstPlayerWinning(int firstPlayerPoints, int secondPlayerPoints) {
        return firstPlayerPoints > secondPlayerPoints;
    }

    private boolean isFortyOrOver(int playerPoints) {
        return playerPoints >=3;
    }

    private boolean isFortyOrUnder(int playerPoints) {
        return playerPoints < 4;
    }

    private boolean isTieGame(int firstPlayerPoints, int secondPlayerPoints) {
        return firstPlayerPoints == secondPlayerPoints;
    }

    public void wonPoint(String player) {
        if (player == playerOneName)
            playerOnePoints++;
        else
            playerTwoPoints++;
    }
}
~~~

So far, we've given things more descriptive names. For example, P1res became playerOneScore. We've distinguished points (value) from score (description). We took a lot of logic that was a little difficult to parse and we've moved it into methods with more descriptive names. For example, "P1point == P2point && P1point < 4" became "isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrUnder(playerOnePoints)". The second is more verbose, but reads more like plain english.

Making the code more readable has better exposed some logic issues. For example, let's look at this section of the code:

{format: Java, caption: Tennis - Logic flaw}
~~~
if (isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrUnder(playerOnePoints))
{
    if (playerOnePoints ==0)
        score = "Love";
    if (playerOnePoints ==1)
        score = "Fifteen";
    if (playerOnePoints ==2)
        score = "Thirty";
    score += "-All";
}
if (isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrOver(playerOnePoints))
    score = "Deuce";
~~~

We're checking to see if it is a tie game and the score is forty or under. If so, we format a response ending in "-All" to send back. We do not yet return the response. Instead, the code continues to the next section where we check to see if it is a tie game and the score is forty or over. If so, we format a "Deuce" response to send back.

Now, imagine it is a game tied at 40. The first check is true (tied and forty or under), so we format the response accordingly with "...-All". The second check is also true (tied and forty or over), so we replace our already formatted response with "Deuce". Why does the first check include 40 if the second check always overrides it? And what would have happened if somebody moved these around into a different order? Suddenly tests would break because a game tied at 40 would say "Forty-All" instead of "Deuce".

There is also a great deal of duplicate logic in the code. There are lines and lines of code that map points to a description:

{format: Java, caption: Tennis - Duplication}
~~~
if (playerOnePoints ==2)
    playerOneScore ="Thirty";
if (playerOnePoints ==3)
    playerOneScore ="Forty";
if (playerTwoPoints ==1)
    playerTwoScore ="Fifteen";
if (playerTwoPoints ==2)
    playerTwoScore ="Thirty";
~~~

Imagine a change in rules where the score progression goes from "Love, Fifteen, Thirty, Forty, All, Deuce, Advantage, Win", to, "Naught, Twenty-Five, Fifty, Seventy-Five, Each, Even, Up, Victory". I mean, of course that would _never_ happen, but, you know, just what if? There are over 40 lines of code involved in converting a score to a description where the description is limited to 8 possible words. That seems a bit much.

Let's reduce this duplication and see what happens.

{format: Java, caption: Tennis - Remove Duplication}
~~~
public class TennisGame
{
    public List<String> Scores = Arrays.asList(new String[]{"Love", "Fifteen", "Thirty", "Forty"});

    private String playerOneName;
    public int playerOnePoints = 0;
    public String playerOneScore = "";

    private String playerTwoName;
    public int playerTwoPoints = 0;
    public String playerTwoScore = "";


    public TennisGame(String player1Name, String player2Name) {
        this.playerOneName = player1Name;
        this.playerTwoName = player2Name;
    }

    public String getScore(){
        String score = "";
        if (isTieGame(playerOnePoints, playerTwoPoints) && isUnderHighestScore(playerOnePoints))
        {
            score = getScore(playerOnePoints) + "-All";
        }
        if (isTieGame(playerOnePoints, playerTwoPoints) && isHighestScoreOrOver(playerOnePoints))
            score = "Deuce";
        
        if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && playerTwoPoints ==0)
        {
            playerOneScore = getScore(playerOnePoints);
            playerTwoScore = getScore(playerTwoPoints);
            score = playerOneScore + "-" + playerTwoScore;
        }
        if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && playerOnePoints ==0)
        {
            playerOneScore = getScore(playerOnePoints);
            playerTwoScore = getScore(playerTwoPoints);
            score = playerOneScore + "-" + playerTwoScore;
        }
        
        if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isHighestScoreOrUnder(playerOnePoints))
        {
            playerOneScore = getScore(playerOnePoints);
            playerTwoScore = getScore(playerTwoPoints);
            score = playerOneScore + "-" + playerTwoScore;
        }
        if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isHighestScoreOrUnder(playerTwoPoints))
        {
            playerOneScore = getScore(playerOnePoints);
            playerTwoScore = getScore(playerTwoPoints);
            score = playerOneScore + "-" + playerTwoScore;
        }
        
        if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isHighestScoreOrOver(playerTwoPoints))
        {
            score = "Advantage " + playerOneName;
        }
        
        if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isHighestScoreOrOver(playerOnePoints))
        {
            score = "Advantage " + playerTwoName;
        }

        if (isOverHighestScore(playerOnePoints) && isAheadByTwoOrMore(playerOnePoints, playerTwoPoints))
        {
            score = "Win for " + playerOneName;
        }
        if (isOverHighestScore(playerTwoPoints) && isAheadByTwoOrMore(playerTwoPoints, playerOnePoints))
        {
            score = "Win for " + playerTwoName;
        }
        return score;
    }

    private String getScore(int playerPoints) {
        return playerPoints <= highestScore() ? Scores.get(playerPoints) : "";
    }

    private boolean isAheadByTwoOrMore(int firstPlayerPoints, int secondPlayerPoints) {
        return (firstPlayerPoints - secondPlayerPoints)>=2;
    }

    private boolean isOverHighestScore(int playerPoints) {
        return playerPoints > highestScore();
    }

    private boolean isUnderHighestScore(int playerPoints) {
        return playerPoints < highestScore();
    }

    private boolean isFirstPlayerWinning(int firstPlayerPoints, int secondPlayerPoints) {
        return firstPlayerPoints > secondPlayerPoints;
    }

    private boolean isHighestScoreOrOver(int playerPoints) {
        return playerPoints >= highestScore();
    }

    private boolean isHighestScoreOrUnder(int playerPoints) {
        return playerPoints <= highestScore();
    }

    private int highestScore() {
        return Scores.size()-1;
    }

    private boolean isTieGame(int firstPlayerPoints, int secondPlayerPoints) {
        return firstPlayerPoints == secondPlayerPoints;
    }

    public void wonPoint(String player) {
        if (player == playerOneName)
            playerOnePoints++;
        else
            playerTwoPoints++;
    }
}
~~~

Let's first take a look at these changes:

{format: Java, caption: Tennis - Scores}
~~~
public List<String> Scores = Arrays.asList(new String[]{"Love", "Fifteen", "Thirty", "Forty"});

...

private String getScore(int playerPoints) {
    return playerPoints <= highestScore() ? Scores.get(playerPoints) : "";
}
~~~

We added a list that holds all of our scores and we added some code to get the right score based on the number of player's points. Now, we have one place where scores are maintained. We could easily change "Love" to "Naught", should we so desire. One single change in one location. Doesn't that seem easier and less risky?

Now let's take a look at the getScore method, specifically the middle of it:

{format: Java, caption: Tennis - Duplication in getScore}
~~~
if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && playerTwoPoints ==0)
{
    playerOneScore = getScore(playerOnePoints);
    playerTwoScore = getScore(playerTwoPoints);
    score = playerOneScore + "-" + playerTwoScore;
}
if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && playerOnePoints ==0)
{
    playerOneScore = getScore(playerOnePoints);
    playerTwoScore = getScore(playerTwoPoints);
    score = playerOneScore + "-" + playerTwoScore;
}

if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isHighestScoreOrUnder(playerOnePoints))
{
    playerOneScore = getScore(playerOnePoints);
    playerTwoScore = getScore(playerTwoPoints);
    score = playerOneScore + "-" + playerTwoScore;
}
if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isHighestScoreOrUnder(playerTwoPoints))
{
    playerOneScore = getScore(playerOnePoints);
    playerTwoScore = getScore(playerTwoPoints);
    score = playerOneScore + "-" + playerTwoScore;
}
~~~

As it turns out, we have a bunch of different conditions that we check for, but no matter what the conditions, we do the same thing. Why check to see if player two is winning and player one has zero points when you're going to do the same thing as if the circumstances were reversed. Since all of these checks do the exact same thing, we can condense them down into one operation. While we are at it, let's make the code just a little more readable.

{format: Java, caption: Tennis}
~~~
public class TennisGame
{

    public List<String> Scores = Arrays.asList(new String[]{"Love", "Fifteen", "Thirty", "Forty"});

    private String playerOneName;
    public int playerOnePoints = 0;

    private String playerTwoName;
    public int playerTwoPoints = 0;


    public TennisGame(String player1Name, String player2Name) {
        this.playerOneName = player1Name;
        this.playerTwoName = player2Name;
    }

    public String getScore(){
        if (isATieGame()) {
            if (isUnderHighestScore()) return getScore(playerOnePoints) + "-All";
            if (isHighestScoreOrOver()) return "Deuce";
        }

        if (isPlayerOneAdvantage()) return "Advantage " + playerOneName;
        if (isPlayerTwoAdvantage()) return "Advantage " + playerTwoName;

        if (isPlayerOneWin()) return "Win for " + playerOneName;
        if (isPlayerTwoWin()) return "Win for " + playerTwoName;

        return standardScore();
    }

    private String standardScore() {
        return getScore(playerOnePoints) + "-" + getScore(playerTwoPoints);
    }

    private boolean isPlayerTwoWin() {
        return isWin(playerTwoPoints, playerOnePoints);
    }

    private boolean isPlayerOneWin() {
        return isWin(playerOnePoints, playerTwoPoints);
    }

    private boolean isPlayerTwoAdvantage() {
        return isAdvantage(playerTwoPoints, playerOnePoints);
    }

    private boolean isPlayerOneAdvantage() {
        return isAdvantage(playerOnePoints, playerTwoPoints);
    }

    private boolean isHighestScoreOrOver() {
        return isHighestScoreOrOver(playerOnePoints);
    }

    private boolean isUnderHighestScore() {
        return isUnderHighestScore(playerOnePoints);
    }

    private boolean isATieGame() {
        return isTieGame(playerOnePoints, playerTwoPoints);
    }

    private boolean isWin(int firstPlayerPoints, int secondPlayerPoints) {
        return isOverHighestScore(firstPlayerPoints) && isAheadByTwoOrMore(firstPlayerPoints, secondPlayerPoints);
    }

    private boolean isAdvantage(int firstPlayerPoints, int secondPlayerPoints) {
        return isFirstPlayerWinning(firstPlayerPoints, secondPlayerPoints) && ( firstPlayerPoints - secondPlayerPoints == 1) && isHighestScoreOrOver(secondPlayerPoints);
    }

    private String getScore(int playerPoints) {
        return playerPoints <= highestScore() ? Scores.get(playerPoints) : "";
    }

    private boolean isAheadByTwoOrMore(int firstPlayerPoints, int secondPlayerPoints) {
        return (firstPlayerPoints - secondPlayerPoints)>=2;
    }

    private boolean isOverHighestScore(int playerPoints) {
        return playerPoints > highestScore();
    }

    private boolean isUnderHighestScore(int playerPoints) {
        return playerPoints < highestScore();
    }

    private boolean isFirstPlayerWinning(int firstPlayerPoints, int secondPlayerPoints) {
        return firstPlayerPoints > secondPlayerPoints;
    }

    private boolean isHighestScoreOrOver(int playerPoints) {
        return playerPoints >= highestScore();
    }

    private boolean isHighestScoreOrUnder(int playerPoints) {
        return playerPoints <= highestScore();
    }

    private int highestScore() {
        return Scores.size()-1;
    }

    private boolean isTieGame(int firstPlayerPoints, int secondPlayerPoints) {
        return firstPlayerPoints == secondPlayerPoints;
    }

    public void wonPoint(String player) {
        if (player == playerOneName)
            playerOnePoints++;
        else
            playerTwoPoints++;
    }
}
~~~

Let's take another look at the getScore() method and contrast where we started to were we are after this work.

{format: Java, caption: Tennis - getScore() before}
~~~
public String getScore(){
    String score = "";
    if (isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrUnder(playerOnePoints))
    {
        if (playerOnePoints ==0)
            score = "Love";
        if (playerOnePoints ==1)
            score = "Fifteen";
        if (playerOnePoints ==2)
            score = "Thirty";
        score += "-All";
    }
    if (isTieGame(playerOnePoints, playerTwoPoints) && isFortyOrOver(playerOnePoints))
        score = "Deuce";
    
    if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && playerTwoPoints ==0)
    {
        if (playerOnePoints ==1)
            playerOneScore = "Fifteen";
        if (playerOnePoints ==2)
            playerOneScore = "Thirty";
        if (playerOnePoints ==3)
            playerOneScore = "Forty";
        
        playerTwoScore = "Love";
        score = playerOneScore + "-" + playerTwoScore;
    }
    if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && playerOnePoints ==0)
    {
        if (playerTwoPoints ==1)
            playerTwoScore = "Fifteen";
        if (playerTwoPoints ==2)
            playerTwoScore = "Thirty";
        if (playerTwoPoints ==3)
            playerTwoScore = "Forty";
        
        playerOneScore = "Love";
        score = playerOneScore + "-" + playerTwoScore;
    }
    
    if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isFortyOrUnder(playerOnePoints))
    {
        if (playerOnePoints ==2)
            playerOneScore ="Thirty";
        if (playerOnePoints ==3)
            playerOneScore ="Forty";
        if (playerTwoPoints ==1)
            playerTwoScore ="Fifteen";
        if (playerTwoPoints ==2)
            playerTwoScore ="Thirty";
        score = playerOneScore + "-" + playerTwoScore;
    }
    if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isFortyOrUnder(playerTwoPoints))
    {
        if (playerTwoPoints ==2)
            playerTwoScore ="Thirty";
        if (playerTwoPoints ==3)
            playerTwoScore ="Forty";
        if (playerOnePoints ==1)
            playerOneScore ="Fifteen";
        if (playerOnePoints ==2)
            playerOneScore ="Thirty";
        score = playerOneScore + "-" + playerTwoScore;
    }
    
    if (isFirstPlayerWinning(playerOnePoints, playerTwoPoints) && isFortyOrOver(playerTwoPoints))
    {
        score = "Advantage " + playerOneName;
    }
    
    if (isFirstPlayerWinning(playerTwoPoints, playerOnePoints) && isFortyOrOver(playerOnePoints))
    {
        score = "Advantage " + playerTwoName;
    }

    if (isOverForty(playerOnePoints) && isAheadByTwoOrMore(playerOnePoints, playerTwoPoints))
    {
        score = "Win for " + playerOneName;
    }
    if (isOverForty(playerTwoPoints) && isAheadByTwoOrMore(playerTwoPoints, playerOnePoints))
    {
        score = "Win for " + playerTwoName;
    }
    return score;
}
~~~

{format: Java, caption: Tennis - getScore() after}
~~~
public String getScore(){
    if (isATieGame()) {
        if (isUnderHighestScore()) return getScore(playerOnePoints) + "-All";
        if (isHighestScoreOrOver()) return "Deuce";
    }

    if (isPlayerOneAdvantage()) return "Advantage " + playerOneName;
    if (isPlayerTwoAdvantage()) return "Advantage " + playerTwoName;

    if (isPlayerOneWin()) return "Win for " + playerOneName;
    if (isPlayerTwoWin()) return "Win for " + playerTwoName;

    return standardScore();
}
~~~

The after version is clearly more readable. Not only is this method more readable, the code is now genuinely easier to test and safer to change. The code now more clearly expresses the intent.

There's still plenty of room for improvement. There is a concept of a score hiding in the code. A score has more than one attribute. A score has both points and an expression, such as 0 and "Love" or 1 and "Fifteen". In our code, this concept is separated and the game needs to know about how to translate points into expressions. There is also a concept of a player hiding in the code. For our purposes, a player has a name and a score. In our code, these concepts are separated and so for each player, we have code that associates a name with points and score. But adding better representation of the concepts for player and score are adventures for another day.

It is important that our code clearly express our intent. The better the code expresses intent, the easier it is to understand and the easier it is to modify in the ways we desire. Ambiguous, clever, or complicated code adds friction. That friction slows progress and creates risk. Just as with a story, the less clearly code expressed its intent, the more likely we are to infer the wrong things.

Refactoring code, changing the implementation without changing the behavior, is a critical skill for achieving clear expression. We showed refactoring in a story to help elucidate the concept. And then we showed refactoring in code to show how much impact the practice can have. The next time you wonder why developers want to refactor, remember this experience. Imaging trying to change "Love" to "Naught" or adding "Twenty" as an additional score option in the first version of the code. This is one of the things refactoring does for the code - it makes is more clear, which makes it easier to add new features.

As we refactored the code, we saw duplication a number of times and sought ways to clean it up. This helped us clearly express our intent. Even in our final version, we have duplication. Notice there are two places where we say "Advantage" and two places where we say "Win".

Let's look more deeply at duplication.

### Duplicates no behavior

We hear a lot about duplicate code in the industry. There are automated code checkers called linters that look for code duplication and metrics dashboards that tell you how much of it you have. These tools look for patterns in the structure of the code. At a minimum, they look for code that is character for character identical.

But Kent is specific with his words. He doesn't say "Duplicates no code", he says, "Duplicates no behavior". Kent is not just talking about duplicate code, he's talking about duplicate behavior. And this is an important distinction.

As it turns out, when you have code that is duplicate in structure and content, you very likely have duplicate behavior. This is what makes code linters helpful. They are able to find places where someone copied code from one area of the source code and pasted it into another. But linters are not good at identifying duplicate behavior.

Let's say we have a screen that shows the average bowling score for a player during a tournament.

{format: Java, caption: Average Tournament Score}
~~~
  // Get tournament scores
  List<Integer> scores = getTournamentScores();

  // Calculate Average Score
  Integer total = 0;
  for ( Integer score : scores ) {
      total += score;
  }
  Double average = Double.valueOf(total/scores.size());
  String displayAverage = average.toString();

  // Display the average
  Text averageText = new Text(displayAverage);

  Group root = new Group(text);   
  Scene scene = new Scene(root, 600, 300);  

  stage.setTitle("Tournament Stats"); 
  stage.setScene(scene); 
     
  stage.show(); 
~~~

A few months later, we need a PDF report that includes the average bowling score for a player for the current year. So we grab the code for calculating the average from the screen and we drop it in. It works.

{format: Java, caption: Average Annual Score}
~~~
  // Get annual scores
  List<Integer> scores = getAnnualScores();

  // Calculate Average Score
  Integer total = 0;
  for ( Integer score : scores ) {
      total += score;
  }
  Double average = Double.valueOf(total/scores.size());
  String displayAverage = average.toString();

  // Display the average
  Font font = FontFactory.getFont(COURIER, 16, BLACK);
  Chunk averageChunk = new Chunk(displayAverage, font);

  Document document = new Document();
  FileOutputStream pdf = new FileOutputStream("AnnualStats.pdf");
  PdfWriter.getInstance(document, pdf);
   
  document.open();

  document.add(averageChunk);
~~~

Let's say we end up doing this a few times. There are different screens and different reports, all of which show average scores based on different criteria such as player age, gender, or region.

Our linter will catch these because they are all literally identical in the way they calculate the average. Every single one of them has this exact same code.

{format: Java, caption: Our Duplicated Code}
~~~
  // Calculate Average Score
  Integer total = 0;
  for ( Integer score : scores ) {
      total += score;
  }
  Double average = Double.valueOf(total/scores.size());
  String displayAverage = average.toString();
~~~

Now, how likely do you think that is? That we've duplicated the same code a dozen times and nobody made a single change to it?

Yeah. Not likely.

It is far more likely that in the dozen instances of average calculation, we have minor differences. There are probably three or four different variants of the same code. We'll have different variable names because total isn't descriptive enough, whereas annualTotal or tournamentTotal is more descriptive. And we'll have different formatting because some of us think that the for loop is concise enough to fit onto one line and some of us think that for loops should never be on a single line.

{format: Java, caption: Annual Score with new variables}
~~~
  // Calculate Average Annual Score
  Integer annualTotal = 0;
  for ( Integer score : scores ) {
      annualTotal += score;
  }
  Double average = Double.valueOf(annualTotal/scores.size());
  String displayAverage = average.toString();
~~~

{format: Java, caption: Tournament Score with new variables and formatting}
~~~
  // Calculate Tournament Average
  Integer tournamentTotal = 0;
  Double tournamentAvg = 0;
  Integer scoreCount = scores.size();
  for ( Integer score : scores ) { tournamentTotal += score; }
  tournamentAvg = Double.valueOf(tournamentTotal/scoreCount);
  String displayAverage = tournamentAvg.toString();
~~~

The more sophisticated linters will still catch this. They ignore insignificant characters such as spaces, tabs and carriage returns. They also ignore comments in the code and can intelligently evaluate variables. These differences will still get caught by any decent linter.

Over time, we make minor modifications to the different areas of the code that calculate averages. Maybe we change where on the screen it is displayed or maybe we want to change the formatting of the display of the average on the screen. Whatever the reasons, the implementation of the various copies of the duplicate code drift over time.

{format: Java, caption: Annual Score with empty check}
~~~
  // Calculate Average Annual Score
  Integer annualTotal = 0;
  Double average = 0.0;

  if (!scores.isEmpty()) {
    for ( Integer score : scores ) {
        annualTotal += score;
    }
    average = Double.valueOf(annualTotal/scores.size());
  }

  String displayAverage = average.toString();
~~~

{format: Java, caption: Tournament score using summary statistics}
~~~
  // Calculate Tournament Average
  IntSummaryStatistics stats = tournamentScores.stream()
    .mapToInt((a) -> a)
    .summaryStatistics();

  String tournamentAverage = stats.getAverage().toString();
~~~

At this point, these two examples are distinctly different in structure, yet they are identical in behavior - they both calculate the average of a set of scores.

As we mentioned earlier, the rule is not "Duplicates no code", but quite deliberately, "Duplicates no behavior."

Duplicate behavior is the actual problem. As we've now seen in our example here, when you have duplicate code - significantly similar in structure and function - you usually have duplicate behavior. But Kent is talking about _any_ duplicate behavior, even those that are structurally different.

Why is that? Why is duplicate behavior an issue?

Let's return to our simple example of calculating an average of bowling scores.

Our handy little application is being used by a number of small leagues and amateur bowlers. Eventually, the United States Bowling Congress (USBC)[^USBC] takes notice and wants to use it, but they need it to support handicaps. This means that the screens and reports that currently show scores and averages will need to show the base values along with the values adjusted for handicap.

[^USBC]: “Home - United States Bowling Congress.” Accessed November 1, 2020. https://bowl.com/. 

To calculate a handicap, you need to take an average of the scores over a minimum of three most recent games, subtract the average from a league basis score to get a delta, and multiply the delta by a league percentage to get the handicap. This is certainly going to make our code more complicated.

But there's more. In league bowling, your handicap changes over time. As you bowl, you are accumulating new scores. Those scores may very well alter your base average, which will alter your delta, which will alter your handicap. So when we want to show the average score for the season along with the average score with handicap for the season, we will have to calculate multiple averages in order to figure out what the handicap adjusted score would have been and then finally calculate the average of all the handicap adjusted scores.

You might be thinking, "No problem. We'll just record the base score and the handicap adjusted score for every game so that we only need to calculate the handicap once." This seems reasonable, except leagues want to run what if scenarios to make sure their basis scores and percentages are fair and it is not unheard of for a league to adjust their handicap basis score or percentage retro-actively in the middle of a season.

Whoah. Didn't see that one coming, did we?

Okay, maybe you did. But my last league bowling experience was 2004 when my then 10 year old son and I joined a father:son league. As far as I know, they didn't use handicaps. This craziness was news to me, my friend.

Given the promise of a lot of new customers, we're happy to add in this new behavior. But how? Where do we begin? Maybe we start with reports and then after we've tested it, we add it into the screens? Maybe we start with the most commonly used aspects of the software?

However we go about this, we're going to need to do a lot of testing. Think about it - the change to annual average is going to be completely different from the change to tournament average. We can't complete the new behavior in one and then copy:paste into the other any more. They're too structurally different for that to work, even though they have the same behavior.

Well, wait a minute... What if we took this opportunity to first get them all back in sync? What if we chose our favorite version of the average calculation - the one that works the fastest or is the easiest to read or maybe is best based on some other set of criteria - and we replaced all of the versions with that one? We could make them all the same again! And that way, we could make the handicap calculation change once and then know it would work for all of them.

That's pretty good. It would prevent us from having to write 12 different versions of the handicap calculation logic. That's handy. (No pun intended) But we still have 12 different copies of the average calculation and we now know that, given time, we'll eventually drift into having 12 different versions of the code floating around. And who knows, what if the USBC does a study and determines that the current handicap calculations need to change in order to be more equitable. Ugh. 12 different changes all over again.

This is the problem with duplicate behavior. Whenever you have duplicate behavior, you have multiple areas of the code that might need to change. Any change, no matter how simple, takes longer for each implementation of the behavior. Not only that - what if you miss one? Or two? Duplicate behavior means more work and more bugs.

What we need to do here is create *one* instance of the average score calculation. It needs to be clean and simple. Calculating an average score needs to be the one job it does; its single responsibility. Anywhere we need an average score calculated, we make a call to this one instance, passing it a list of scores, and it gives us back the average.

{format: Java, caption: Calculate Average Method}
~~~
public class ScoreCalculator {
  public static Double average(List<Integer> scores) {

    IntSummaryStatistics stats = scores.stream()
      .mapToInt((a) -> a)
      .summaryStatistics();
          
    return stats.getAverage();
  }
}
~~~

{format: Java, caption: Average Tournament Score}
~~~
  // Get tournament scores
  List<Integer> scores = getTournamentScores();

  // Calculate Average Score
  String displayAverage = ScoreCalculator.average(scores).toString();

  // Display the average
  Text averageText = new Text(displayAverage);

  Group root = new Group(text);   
  Scene scene = new Scene(root, 600, 300);  

  stage.setTitle("Tournament Stats"); 
  stage.setScene(scene); 
     
  stage.show(); 
~~~

{format: Java, caption: Average Annual Score}
~~~
  // Get annual scores
  List<Integer> scores = getAnnualScores();

  // Calculate Average Score
  String displayAverage = ScoreCalculator.average(scores).toString();

  // Display the average
  Font font = FontFactory.getFont(COURIER, 16, BLACK);
  Chunk averageChunk = new Chunk(displayAverage, font);

  Document document = new Document();
  FileOutputStream pdf = new FileOutputStream("AnnualStats.pdf");
  PdfWriter.getInstance(document, pdf);
   
  document.open();

  document.add(averageChunk);
~~~

Having completed that exercise, we now have one place where score averages are calculated. Any change to how score averages are calculated can be made in one place and will automatically work everywhere in the application.

One commonly accepted principle of software development is The Single Responsibility Principle (SRP)[^SRP]. SRP states that each software module should have one and only one reason to change. While the principle does not state this explicitly, I tend to add, "Each reason to change should be represented in one and only one module." So each module within a solution has a specific and discrete purpose and is the only module within the solution that provides that purpose.

[^SRP]: “Single Responsibility Principle.” wiki.c2.com, March 23, 2010. https://wiki.c2.com/?SingleResponsibilityPrinciple. 

This is what is means to duplicate no behavior. Each module within a solution has a specific, discrete, and unique purpose.

Closely related to the SRP initialization is the more memorable DRY acronym. DRY (Don't Repeat Yourself), from the book, The Pragmatic Programmer, states, "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system." You might hear a developer refer to code as DRY or not DRY, indicating whether or not it has repeated logic. I've also heard people use the acronym WET "write every time" to refer to code with excessive duplication, but I wouldn't say this has caught on in the industry as a "standard".

Simple things are not often easy to create. In fact, teams often build complicated things and then may or may not break it apart into simple pieces. The refactorings I've shown you thus far are typical

## In Small Steps
