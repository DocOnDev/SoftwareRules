{#create_simple_things}
# Create simple things in small steps.

{icon: quote-left}
B> ## The most fundamental problem in software development is complexity. There is only one basic way of dealing with complexity: divide and conquer.

B> ### -- Bjarne Stroustrup

## Create Simple Things

This sounds easy enough. Create simple things. But, what is a simple thing?

Simple might indicate something that has few components or something that is easy to understand. Simple might also indicate something that is lacking intellect or something that is gullible. As we are talking about code, which is non-sentient, the former makes more sense.

So we might say that simple code has few components and is easy to understand. But I think this definition lacks something. I could have code that has few components, is easy to understand, and fails to reliably accomplish the desired outcome.

Kent Beck[^KentBeck], creator of jUnit and a member of the team that created Extreme Programming (XP), describes Simple Design using 4 rules[^SimplicityRules]:
1. Passes all the tests.
1. Express every idea we need to express.
1. Duplicates no behavior or configuration.
1. Has no superfluous parts.

[^KentBeck]: “Kent Beck.” Wikipedia. Wikimedia Foundation, February 7, 2020. https://en.wikipedia.org/wiki/Kent_Beck.

[^SimplicityRules]: Cunningham, Ward, Kent Beck, and Ron Jeffries. “XP Simplicity Rules.” wiki.c2.com, November 12, 2014. https://wiki.c2.com/?XpSimplicityRules.

First and foremost, Kent's idea of simple includes tests. Now, he doesn't specify automated tests, much less unit tests or Test Driven Design (TDD) in his definition. //TODO: TDD Reference

I think TDD is a fair inference considering these are Kent's rules. But that's not the point at the moment. The point, dear reader, is that Kent's rules for simple design include that the code passes all the tests.

### Passes all the tests.

All the tests. Not some of the tests. All of them.

All of what tests?
All of the tests we have?
All of the tests we decided to write?

No - all of the tests necessary to verify the software works as desired. The point of "passes all the tests" is that the code reliably accomplishes the desired outcome.

Now Kent's rules are in order of importance. While rule 2 and 3 have swapped place over the years due to changes in industry trends and more or less utilization of frameworks, rule number one has always been rule number one. Make sure the software does what it is supposed to do.

### Expresses every idea we need to express


### Duplicates no behavior or configuration

We hear a lot about duplicate code in the industry. There are automated code checkers called linters that look for code duplication and metrics dashboards that tell you how much of it you have. These tools look for patterns in the structure of the code. At a minimum, they look for code that is character for character identical.

But Kent is specific with his words. He doesn't say "Duplicates no code or configuration", he says, "Duplicates no behavior or configuration". Kent is not just talking about duplicate code, he's talking about duplicate behavior. And this is an important distinction.

As it turns out, when you have code that is duplicate in structure and content, you very likely have duplicate behavior. This is what makes code linters helpful. They are able to find places where someone copied code from one area of the source code and pasted it into another. But linters are not good at identifying duplicate behavior.

Let's say we have a screen that shows the average bowling score for a player during a tournament.

{format: Java, caption: Average Tournament Score}
~~~
// Get tournament scores
List<Integer> scores = getTournamentScores();

// Calculate Average Score
Integer total = 0;
for ( Integer score : scores ) {
    total += score;
}
Double average = Double.valueOf(total / scores.size());
String displayAverage = average.toString();

// Display the average
Text averageText = new Text(displayAverage);

Group root = new Group(text);   
Scene scene = new Scene(root, 600, 300);  

stage.setTitle("Tournament Stats"); 
stage.setScene(scene); 
   
stage.show(); 

~~~

A few months later, we need a PDF report that includes the average bowling score for a player for the current year. So we grab the code for calculating the average from the screen and we drop it in. It works.

{format: Java, caption: Average Annual Score}
~~~
// Get annual scores
List<Integer> scores = getAnnualScores();

// Calculate Average Score
Integer total = 0;
for ( Integer score : scores ) {
    total += score;
}
Double average = Double.valueOf(total / scores.size());
String displayAverage = average.toString();

// Display the average
Chunk averageChunk = new Chunk(displayAverage, font);

Document document = new Document();
PdfWriter.getInstance(document, new FileOutputStream("AnnualStats.pdf"));
 
document.open();
Font font = FontFactory.getFont(FontFactory.COURIER, 16, BaseColor.BLACK);

document.add(averageChunk);

~~~

Let's say we end up doing this a few times. There are different screens and different reports, all of which show average scores based on different criteria such as player age, gender, or region.

Our linter will catch these because they are all literally identical in the way they calculate the average. Every single one of them has this exact same code.

{format: Java, caption: Our Duplicated Code}
~~~
// Calculate Average Score
Integer total = 0;
for ( Integer score : scores ) {
    total += score;
}
Double average = Double.valueOf(total / scores.size());
String displayAverage = average.toString();
~~~

Now, how likely do you think that is? That we've duplicated the same code a dozen times and nobody made a single change to it?

Yeah. Not likely.

It is far more likely that in the dozen instances of average calculation, we have minor differences. There are probably three or four different variants of the same code. We'll have different variable names because total isn't descriptive enough, whereas annualTotal or tournamentTotal is more descriptive. And we'll have different formatting because some of us think that the for loop is concise enough to fit onto one line and some of us think that for loops should never be on a single line.

{format: Java, caption: Annual Score with new variables}
~~~
// Calculate Average Annual Score
Integer annualTotal = 0;
for ( Integer score : scores ) {
    annualTotal += score;
}
Double average = Double.valueOf(annualTotal / scores.size());
String displayAverage = average.toString();
~~~

{format: Java, caption: Tournament Score with new variables and formatting}
~~~
// Calculate Tournament Average
Integer tournamentTotal = 0;
Double tournamentAvg = 0;
Integer scoreCount = scores.size();
for ( Integer score : scores ) { tournamentTotal += score; }
tournamentAvg = Double.valueOf(tournamentTotal / scoreCount);
String displayAverage = tournamentAvg.toString();
~~~

The more sophisticated linters will still catch this. They ignore insignificant characters such as spaces, tabs and carriage returns. They also ignore comments in the code and can intelligently evaluate variables. These differences will still get caught by any decent linter.

Over time, we make minor modifications to the different areas of the code that calculate averages. Maybe we change where on the screen it is displayed or maybe we want to change the formatting of the display of the average on the screen. Whatever the reasons, the implementation of the various copies of the duplicate code drift over time.

{format: Java, caption: Annual Score with empty check}
~~~
// Calculate Average Annual Score
Integer annualTotal = 0;
Double average = 0.0;

if (!scores.isEmpty()) {
  for ( Integer score : scores ) {
      annualTotal += score;
  }
  average = Double.valueOf(annualTotal / scores.size());
}

String displayAverage = average.toString();
~~~

{format: Java, caption: Tournament score using streams and summary statistics}
~~~
// Calculate Tournament Average
IntSummaryStatistics summaryStats = tournamentScores.stream()
        .mapToInt((a) -> a)
        .summaryStatistics();

String tournamentAverage = summaryStats.getAverage().toString();
~~~

At this point, these two examples are distinctly different in structure, yet they are identical in behavior - they both calculate the average of a set of scores.

As we mentioned earlier, the rule is not "Duplicates no code or configuration", but quite deliberately, "Duplicates no behavior or configuration."

Duplicate behavior is the actual problem. As we've now seen in our example here, when you have duplicate code - significantly similar in structure and function - you usually have duplicate behavior. But Kent is talking about _any_ duplicate behavior, even those that are structurally different.

Why is that? Why is duplicate behavior an issue?

Let's return to our example of calculating an average of bowling scores.
Let's return to our simple example of calculating an average of bowling scores.

Our handy little application is being used by a number of small leagues and amateur bowlers. Eventually, the United States Bowling Congress (USBC)[^USBC] takes notice and wants to use it, but they need it to support handicaps. This means that the screens and reports that currently show scores and averages will need to show the base values along with the values adjusted for handicap.

[^USBC]: Home - United States Bowling Congress. (n.d.). Retrieved November 01, 2020, from https://bowl.com/

To calculate a handicap, you need to take an average of the scores over a minimum of three most recent games, subtract the average from a league basis score to get a delta, and multiply the delta by a league percentage to get the handicap. This is certainly going to make our code more complicated.

But there's more. In league bowling, your handicap changes over time. As you bowl, you are accumulating new scores. Those scores may very well alter your base average, which will alter your delta, which will alter your handicap. So when we want to show the average score for the season along with the average score with handicap for the season, we will have to calculate multiple averages in order to figure out what the handicap adjusted score would have been and then finally calculate the average of all the handicap adjusted scores.

You might be thinking, "No problem. We'll just record the base score and the handicap adjusted score for every game so that we only need to calculate the handicap once." And you'd be right, except leagues want to run what if scenarios to make sure their basis scores and percentages are fair and it is not unheard of for a local league to adjust their handicap basis score or percentage retro-actively in the middle of a season.
You might be thinking, "No problem. We'll just record the base score and the handicap adjusted score for every game so that we only need to calculate the handicap once." This seems reasonable, except leagues want to run what if scenarios to make sure their basis scores and percentages are fair and it is not unheard of for a league to adjust their handicap basis score or percentage retro-actively in the middle of a season.

Whoah. Didn't see that one coming, did we?

Okay, maybe you did. But my last league bowling experience was 2004 when my then 10 year old son and I joined a father:son league. As far as I know, they didn't use handicaps.



Simple things are not often easy to create. In fact, we often start with a complicated thing and then break it apart into simple pieces.

## In Small Steps
